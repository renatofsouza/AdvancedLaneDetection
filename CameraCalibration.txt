import numpy as np
import cv2
import glob
import matplotlib.pyplot as plt
import pickle

# The CameraCalibration class uses a chessboard to calibrate camera distortions. 
# The class requires the number of 
class CameraCalibraion(object):

    def __init__(self, callibration_images_folder, shape = (0,0)):
        
        self.images_folder = callibration_images_folder
        self.shape = shape

        # 3d points in real world space. 
        self.object_points = [] 
        
        # 2d points in image space
        self.image_points = [] 

        self.calibrated = False

    
    def calibrate(self,draw_images=False):

        # Prepare an array with all the object points. Each point has a (x,y,z) coordinate. 
        # The size of the array is the number of inside corners in the chessboard
        # Note, since the chessboard is in a plane, the z coordinate will
        # always be cosidered 0. 
        objp = np.zeros((self.shape[0] * self.shape[1],3),np.float32)
        objp[:,:2] = np.mgrid[0:self.shape[0], 0:self.shape[1]].T.reshape(-1,2)
                
        # Make a list of calibration images
        images = glob.glob(self.images_folder + '/*.jpg')
        if len(images) == 0:
            raise("Folder does not contain any calibration images. Images must be in jpg format.")

        # Step through the list and search for chessboard corners
        for idx, fname in enumerate(images):
            img = cv2.imread(fname)
            gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

            # Find the chessboard corners
            ret, corners = cv2.findChessboardCorners(gray, self.shape, None)

            # If found, add object points, image points
            if ret == True:
                self.object_points.append(objp)
                self.image_points.append(corners)
                img_size = (img.shape[1], img.shape[0]) # TODO: img_size is only used after the loop

                if draw_images:
                    # Draw and display the corners
                    cv2.drawChessboardCorners(img, self.shape, corners, ret)
                    cv2.imshow('img', img)
                    cv2.waitKey(500)
                    
        cv2.destroyAllWindows()
        # Use the size of last image to calibrate camera given object points and image points  
        ret, mtx, dist, rvecs, tvecs = cv2.calibrateCamera(self.object_points, self.image_points,img_size ,None,None)
        
        self.retval = ret
        self.camera_matrix = mtx
        self.distortion_coefs = dist
        self.rvecs = rvecs
        self.tvecs = tvecs
        self.calibrated = True

    # Test undistortion on an image
    def test(self, src_img_path):

        img = cv2.imread(src_img_path)

        dst = cv2.undistort(img, self.camera_matrix, self.distortion_coefs, None, self.camera_matrix)

        # Visualize undistortion
        f, (ax1, ax2) = plt.subplots(1, 2, figsize=(20,10))
        ax1.imshow(img)
        ax1.set_title('Original Image', fontsize=30)
        ax2.imshow(dst)
        ax2.set_title('Undistorted Image', fontsize=30)
        plt.show()

    def cal_undistort(img, objpoints, imgpoints):
        img_size = (img.shape[0],img.shape[1])
        ret, mtx, dist, rvecs, tvecs = cv2.calibrateCamera(objpoints, imgpoints, img_size,None,None)
        img_undist = cv2.undistort(img,mtx,dist)

        return img_undist

